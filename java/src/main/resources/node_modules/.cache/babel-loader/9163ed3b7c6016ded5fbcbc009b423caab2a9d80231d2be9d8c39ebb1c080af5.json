{"ast":null,"code":"var _jsxFileName = \"/Users/ujkan/Desktop/uni/projects/tictactoe/java/src/main/resources/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\n\n//const App = () => {\n//  // State to keep track of the current player (X or O)\n//  const [currentPlayer, setCurrentPlayer] = useState('X');\n//\n//  // State to keep track of the cells and their contents\n//  const [grid, setGrid] = useState([\n//    ['', '', ''],\n//    ['', '', ''],\n//    ['', '', ''],\n//  ]);\n//\n//  // Fetch the current game state from the API when the component mounts\n//  useEffect(() => {\n//    fetch('/board')\n//      .then(response => response.json())\n//      .then(data => {\n//        setGrid(data.grid);\n//        setCurrentPlayer(data.currentPlayer);\n//      });\n//  }, []);\n//\n//  // Function to handle clicks on the grid cells\n//  const handleCellClick = (row, col) => {\n//    // Ignore the click if the cell is already filled\n//    if (grid[row][col] !== '') {\n//      return;\n//    }\n//\n//    // Update the grid with the current player's symbol\n//    const updatedGrid = [...grid];\n//    updatedGrid[row][col] = currentPlayer;\n//\n//    // Check if the game is over\n//    const gameOver = false;\n//\n//    let nextPlayer;\n//    if (gameOver) {\n//      // If the game is over, don't switch to the other player\n//      nextPlayer = currentPlayer;\n//    } else {\n//      // Switch to the other player\n//      nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n//\n//      // If the other player is the AI, make a move on behalf of the AI\n//      if (nextPlayer === 'O') {\n//        fetch('/ai')\n//          .then(response => response.json())\n//          .then(aiMove => {\n//            // Update the grid with the AI's move\n//            const newGrid = [...updatedGrid];\n//            newGrid[aiMove.row][aiMove.col] = 'O';\n//\n//            // Check if the game is over after the AI's move\n//            const newGameOver = false;\n//\n//            // Update the state with the new grid and current player\n//            setGrid(newGrid);\n//            setCurrentPlayer(newGameOver ? 'O' : 'X');\n//\n//            // Send the updated game state to the API\n//            fetch('../../src/api/game', {\n//              method: 'PUT',\n//              headers: { 'Content-Type': 'application/json' },\n//              body: JSON.stringify({ grid: newGrid, currentPlayer: nextPlayer }),\n//            });\n//          });\n//      }\n//    }\n//\n//    // Update the state with the new grid and current player\n//    setGrid(updatedGrid);\n//    setCurrentPlayer(nextPlayer);\n//\n//    // Send the updated game state to the API\n//    fetch('/api/game', {\n//      method: 'PUT',\n//      headers: { 'Content-Type': 'application/json' },\n//      body: JSON.stringify({ grid: updatedGrid, currentPlayer\n//\n//      })\n//    });\n//    return (\n//        <div>\n//          <div className=\"grid\">\n//            {grid.map((row, rowIndex) => (\n//              <div key={rowIndex} className=\"grid-row\">\n//                {row.map((col, colIndex) => (\n//                  <div\n//                    key={colIndex}\n//                    className=\"grid-cell\"\n//                    onClick={() => handleCellClick(rowIndex, colIndex)}\n//                  >\n//                    {col}\n//                  </div>\n//                ))}\n//              </div>\n//            ))}\n//          </div>\n//        </div>\n//      );\n//  }}\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App(props) {\n  _s();\n  const [currentPlayer, setCurrentPlayer] = useState('X');\n\n  // State to keep track of the cells and their contents\n  const [grid, setGrid] = useState([['', '', ''], ['', '', ''], ['', '', '']]);\n\n  // Function to handle clicks on the grid cells\n  const handleCellClick = (row, col) => {\n    // Ignore the click if the cell is already filled\n    if (grid[row][col] !== '') {\n      return;\n    }\n\n    // Update the grid with the current player's symbol\n    const updatedGrid = [...grid];\n    updatedGrid[row][col] = currentPlayer;\n\n    // Switch to the other player\n    const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n    if (currentPlayer === 'X') {\n      fetch;\n    }\n\n    // Update the state with the new grid and current player\n    setGrid(updatedGrid);\n    setCurrentPlayer(nextPlayer);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((col, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"grid-cell\",\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: col\n        }, colIndex, false, {\n          fileName: _jsxFileName,\n          lineNumber: 144,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 142,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 140,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 139,\n    columnNumber: 5\n  }, this);\n}\n\n// Log to console\n_s(App, \"rTbbhWrsBR3E1G1G/aa4g6E6TPM=\");\n_c = App;\nconsole.log('Hello console');\n\n// Log to console\nconsole.log('Hello console');\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","App","props","currentPlayer","setCurrentPlayer","grid","setGrid","handleCellClick","row","col","updatedGrid","nextPlayer","fetch","map","rowIndex","colIndex","console","log"],"sources":["/Users/ujkan/Desktop/uni/projects/tictactoe/java/src/main/resources/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\n//const App = () => {\n//  // State to keep track of the current player (X or O)\n//  const [currentPlayer, setCurrentPlayer] = useState('X');\n//\n//  // State to keep track of the cells and their contents\n//  const [grid, setGrid] = useState([\n//    ['', '', ''],\n//    ['', '', ''],\n//    ['', '', ''],\n//  ]);\n//\n//  // Fetch the current game state from the API when the component mounts\n//  useEffect(() => {\n//    fetch('/board')\n//      .then(response => response.json())\n//      .then(data => {\n//        setGrid(data.grid);\n//        setCurrentPlayer(data.currentPlayer);\n//      });\n//  }, []);\n//\n//  // Function to handle clicks on the grid cells\n//  const handleCellClick = (row, col) => {\n//    // Ignore the click if the cell is already filled\n//    if (grid[row][col] !== '') {\n//      return;\n//    }\n//\n//    // Update the grid with the current player's symbol\n//    const updatedGrid = [...grid];\n//    updatedGrid[row][col] = currentPlayer;\n//\n//    // Check if the game is over\n//    const gameOver = false;\n//\n//    let nextPlayer;\n//    if (gameOver) {\n//      // If the game is over, don't switch to the other player\n//      nextPlayer = currentPlayer;\n//    } else {\n//      // Switch to the other player\n//      nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n//\n//      // If the other player is the AI, make a move on behalf of the AI\n//      if (nextPlayer === 'O') {\n//        fetch('/ai')\n//          .then(response => response.json())\n//          .then(aiMove => {\n//            // Update the grid with the AI's move\n//            const newGrid = [...updatedGrid];\n//            newGrid[aiMove.row][aiMove.col] = 'O';\n//\n//            // Check if the game is over after the AI's move\n//            const newGameOver = false;\n//\n//            // Update the state with the new grid and current player\n//            setGrid(newGrid);\n//            setCurrentPlayer(newGameOver ? 'O' : 'X');\n//\n//            // Send the updated game state to the API\n//            fetch('../../src/api/game', {\n//              method: 'PUT',\n//              headers: { 'Content-Type': 'application/json' },\n//              body: JSON.stringify({ grid: newGrid, currentPlayer: nextPlayer }),\n//            });\n//          });\n//      }\n//    }\n//\n//    // Update the state with the new grid and current player\n//    setGrid(updatedGrid);\n//    setCurrentPlayer(nextPlayer);\n//\n//    // Send the updated game state to the API\n//    fetch('/api/game', {\n//      method: 'PUT',\n//      headers: { 'Content-Type': 'application/json' },\n//      body: JSON.stringify({ grid: updatedGrid, currentPlayer\n//\n//      })\n//    });\n//    return (\n//        <div>\n//          <div className=\"grid\">\n//            {grid.map((row, rowIndex) => (\n//              <div key={rowIndex} className=\"grid-row\">\n//                {row.map((col, colIndex) => (\n//                  <div\n//                    key={colIndex}\n//                    className=\"grid-cell\"\n//                    onClick={() => handleCellClick(rowIndex, colIndex)}\n//                  >\n//                    {col}\n//                  </div>\n//                ))}\n//              </div>\n//            ))}\n//          </div>\n//        </div>\n//      );\n//  }}\n\nexport default function App(props) {\n const [currentPlayer, setCurrentPlayer] = useState('X');\n\n  // State to keep track of the cells and their contents\n  const [grid, setGrid] = useState([\n    ['', '', ''],\n    ['', '', ''],\n    ['', '', ''],\n  ]);\n\n  // Function to handle clicks on the grid cells\n  const handleCellClick = (row, col) => {\n    // Ignore the click if the cell is already filled\n    if (grid[row][col] !== '') {\n      return;\n    }\n\n    // Update the grid with the current player's symbol\n    const updatedGrid = [...grid];\n    updatedGrid[row][col] = currentPlayer;\n\n    // Switch to the other player\n    const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n\n    if (currentPlayer === 'X') {\n        fetch\n    }\n\n    // Update the state with the new grid and current player\n    setGrid(updatedGrid);\n    setCurrentPlayer(nextPlayer);\n  }\n\n  return (\n    <div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((col, colIndex) => (\n              <div\n                key={colIndex}\n                className=\"grid-cell\"\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {col}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Log to console\nconsole.log('Hello console')\n\n\n// Log to console\nconsole.log('Hello console')\n\n\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA,eAAe,SAASC,GAAG,CAACC,KAAK,EAAE;EAAA;EAClC,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGL,QAAQ,CAAC,GAAG,CAAC;;EAEtD;EACA,MAAM,CAACM,IAAI,EAAEC,OAAO,CAAC,GAAGP,QAAQ,CAAC,CAC/B,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACZ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACZ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CACb,CAAC;;EAEF;EACA,MAAMQ,eAAe,GAAG,CAACC,GAAG,EAAEC,GAAG,KAAK;IACpC;IACA,IAAIJ,IAAI,CAACG,GAAG,CAAC,CAACC,GAAG,CAAC,KAAK,EAAE,EAAE;MACzB;IACF;;IAEA;IACA,MAAMC,WAAW,GAAG,CAAC,GAAGL,IAAI,CAAC;IAC7BK,WAAW,CAACF,GAAG,CAAC,CAACC,GAAG,CAAC,GAAGN,aAAa;;IAErC;IACA,MAAMQ,UAAU,GAAGR,aAAa,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;IAEpD,IAAIA,aAAa,KAAK,GAAG,EAAE;MACvBS,KAAK;IACT;;IAEA;IACAN,OAAO,CAACI,WAAW,CAAC;IACpBN,gBAAgB,CAACO,UAAU,CAAC;EAC9B,CAAC;EAED,oBACE;IAAA,uBACE;MAAK,SAAS,EAAC,MAAM;MAAA,UAClBN,IAAI,CAACQ,GAAG,CAAC,CAACL,GAAG,EAAEM,QAAQ,kBACtB;QAAoB,SAAS,EAAC,UAAU;QAAA,UACrCN,GAAG,CAACK,GAAG,CAAC,CAACJ,GAAG,EAAEM,QAAQ,kBACrB;UAEE,SAAS,EAAC,WAAW;UACrB,OAAO,EAAE,MAAMR,eAAe,CAACO,QAAQ,EAAEC,QAAQ,CAAE;UAAA,UAElDN;QAAG,GAJCM,QAAQ;UAAA;UAAA;UAAA;QAAA,QAMhB;MAAC,GATMD,QAAQ;QAAA;QAAA;QAAA;MAAA,QAWnB;IAAC;MAAA;MAAA;MAAA;IAAA;EACE;IAAA;IAAA;IAAA;EAAA,QACF;AAEV;;AAEA;AAAA,GAtDwBb,GAAG;AAAA,KAAHA,GAAG;AAuD3Be,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;;AAG5B;AACAD,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}