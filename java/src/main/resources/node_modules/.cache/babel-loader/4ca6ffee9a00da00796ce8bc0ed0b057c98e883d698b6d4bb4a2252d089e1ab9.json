{"ast":null,"code":"var _jsxFileName = \"/Users/ujkan/Desktop/uni/projects/tictactoe/java/src/main/resources/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\n\n//const App = () => {\n//  // State to keep track of the current player (X or O)\n//  const [currentPlayer, setCurrentPlayer] = useState('X');\n//\n//  // State to keep track of the cells and their contents\n//  const [grid, setGrid] = useState([\n//    ['', '', ''],\n//    ['', '', ''],\n//    ['', '', ''],\n//  ]);\n//\n//  // Fetch the current game state from the API when the component mounts\n//  useEffect(() => {\n//    fetch('/board')\n//      .then(response => response.json())\n//      .then(data => {\n//        setGrid(data.grid);\n//        setCurrentPlayer(data.currentPlayer);\n//      });\n//  }, []);\n//\n//  // Function to handle clicks on the grid cells\n//  const handleCellClick = (row, col) => {\n//    // Ignore the click if the cell is already filled\n//    if (grid[row][col] !== '') {\n//      return;\n//    }\n//\n//    // Update the grid with the current player's symbol\n//    const updatedGrid = [...grid];\n//    updatedGrid[row][col] = currentPlayer;\n//\n//    // Check if the game is over\n//    const gameOver = false;\n//\n//    let nextPlayer;\n//    if (gameOver) {\n//      // If the game is over, don't switch to the other player\n//      nextPlayer = currentPlayer;\n//    } else {\n//      // Switch to the other player\n//      nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n//\n//      // If the other player is the AI, make a move on behalf of the AI\n//      if (nextPlayer === 'O') {\n//        fetch('/ai')\n//          .then(response => response.json())\n//          .then(aiMove => {\n//            // Update the grid with the AI's move\n//            const newGrid = [...updatedGrid];\n//            newGrid[aiMove.row][aiMove.col] = 'O';\n//\n//            // Check if the game is over after the AI's move\n//            const newGameOver = false;\n//\n//            // Update the state with the new grid and current player\n//            setGrid(newGrid);\n//            setCurrentPlayer(newGameOver ? 'O' : 'X');\n//\n//            // Send the updated game state to the API\n//            fetch('../../src/api/game', {\n//              method: 'PUT',\n//              headers: { 'Content-Type': 'application/json' },\n//              body: JSON.stringify({ grid: newGrid, currentPlayer: nextPlayer }),\n//            });\n//          });\n//      }\n//    }\n//\n//    // Update the state with the new grid and current player\n//    setGrid(updatedGrid);\n//    setCurrentPlayer(nextPlayer);\n//\n//    // Send the updated game state to the API\n//    fetch('/api/game', {\n//      method: 'PUT',\n//      headers: { 'Content-Type': 'application/json' },\n//      body: JSON.stringify({ grid: updatedGrid, currentPlayer\n//\n//      })\n//    });\n//    return (\n//        <div>\n//          <div className=\"grid\">\n//            {grid.map((row, rowIndex) => (\n//              <div key={rowIndex} className=\"grid-row\">\n//                {row.map((col, colIndex) => (\n//                  <div\n//                    key={colIndex}\n//                    className=\"grid-cell\"\n//                    onClick={() => handleCellClick(rowIndex, colIndex)}\n//                  >\n//                    {col}\n//                  </div>\n//                ))}\n//              </div>\n//            ))}\n//          </div>\n//        </div>\n//      );\n//  }}\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App(props) {\n  _s();\n  const [currentPlayer, setCurrentPlayer] = useState('X');\n\n  // State to keep track of the cells and their contents\n  const [grid, setGrid] = useState([['', '', ''], ['', '', ''], ['', '', '']]);\n\n  // Function to handle clicks on the grid cells\n  const handleCellClick = async (row, col) => {\n    // Ignore the click if the cell is already filled\n    if (grid[row][col] !== '') {\n      return;\n    }\n\n    // Update the grid with the current player's symbol\n    const updatedGrid = [...grid];\n    updatedGrid[row][col] = currentPlayer;\n    const mv = fetch('http://localhost:8080/board', {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        pos: row * 3 + col\n      })\n    }).then(response => response.json());\n    fetch('http://localhost:8080/board').then(response => console.log(response.json()));\n    // Switch to the other player\n    const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n    if (nextPlayer === 'O') {\n      fetch('http://localhost:8080/ai').then(response => response.json()).then(aiMove => {\n        // Update the grid with the AI's move\n        var newGrid = [...updatedGrid];\n        newGrid[Math.floor(aiMove / 3)][aiMove % 3] = 'O';\n        var newBoard = [].concat.apply([], newGrid);\n        console.log(\"HEY\");\n        console.log(newBoard);\n        // Check if the game is over after the AI's move\n        const newGameOver = false;\n\n        // Update the state with the new grid and current player\n        setGrid(newGrid);\n        setCurrentPlayer(newGameOver ? 'O' : 'X');\n\n        // Send the updated game state to the API\n        console.log(JSON.stringify({\n          pos: aiMove\n        }));\n      });\n    }\n\n    // Update the state with the new grid and current player\n    setGrid(updatedGrid);\n    setCurrentPlayer(currentPlayer);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((col, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"grid-cell\",\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: col\n        }, colIndex, false, {\n          fileName: _jsxFileName,\n          lineNumber: 172,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 170,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 168,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 167,\n    columnNumber: 5\n  }, this);\n}\n\n// Log to console\n_s(App, \"rTbbhWrsBR3E1G1G/aa4g6E6TPM=\");\n_c = App;\nconsole.log('Hello console');\n\n// Log to console\nconsole.log('Hello console');\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","App","props","currentPlayer","setCurrentPlayer","grid","setGrid","handleCellClick","row","col","updatedGrid","mv","fetch","method","headers","body","JSON","stringify","pos","then","response","json","console","log","nextPlayer","aiMove","newGrid","Math","floor","newBoard","concat","apply","newGameOver","map","rowIndex","colIndex"],"sources":["/Users/ujkan/Desktop/uni/projects/tictactoe/java/src/main/resources/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\n//const App = () => {\n//  // State to keep track of the current player (X or O)\n//  const [currentPlayer, setCurrentPlayer] = useState('X');\n//\n//  // State to keep track of the cells and their contents\n//  const [grid, setGrid] = useState([\n//    ['', '', ''],\n//    ['', '', ''],\n//    ['', '', ''],\n//  ]);\n//\n//  // Fetch the current game state from the API when the component mounts\n//  useEffect(() => {\n//    fetch('/board')\n//      .then(response => response.json())\n//      .then(data => {\n//        setGrid(data.grid);\n//        setCurrentPlayer(data.currentPlayer);\n//      });\n//  }, []);\n//\n//  // Function to handle clicks on the grid cells\n//  const handleCellClick = (row, col) => {\n//    // Ignore the click if the cell is already filled\n//    if (grid[row][col] !== '') {\n//      return;\n//    }\n//\n//    // Update the grid with the current player's symbol\n//    const updatedGrid = [...grid];\n//    updatedGrid[row][col] = currentPlayer;\n//\n//    // Check if the game is over\n//    const gameOver = false;\n//\n//    let nextPlayer;\n//    if (gameOver) {\n//      // If the game is over, don't switch to the other player\n//      nextPlayer = currentPlayer;\n//    } else {\n//      // Switch to the other player\n//      nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n//\n//      // If the other player is the AI, make a move on behalf of the AI\n//      if (nextPlayer === 'O') {\n//        fetch('/ai')\n//          .then(response => response.json())\n//          .then(aiMove => {\n//            // Update the grid with the AI's move\n//            const newGrid = [...updatedGrid];\n//            newGrid[aiMove.row][aiMove.col] = 'O';\n//\n//            // Check if the game is over after the AI's move\n//            const newGameOver = false;\n//\n//            // Update the state with the new grid and current player\n//            setGrid(newGrid);\n//            setCurrentPlayer(newGameOver ? 'O' : 'X');\n//\n//            // Send the updated game state to the API\n//            fetch('../../src/api/game', {\n//              method: 'PUT',\n//              headers: { 'Content-Type': 'application/json' },\n//              body: JSON.stringify({ grid: newGrid, currentPlayer: nextPlayer }),\n//            });\n//          });\n//      }\n//    }\n//\n//    // Update the state with the new grid and current player\n//    setGrid(updatedGrid);\n//    setCurrentPlayer(nextPlayer);\n//\n//    // Send the updated game state to the API\n//    fetch('/api/game', {\n//      method: 'PUT',\n//      headers: { 'Content-Type': 'application/json' },\n//      body: JSON.stringify({ grid: updatedGrid, currentPlayer\n//\n//      })\n//    });\n//    return (\n//        <div>\n//          <div className=\"grid\">\n//            {grid.map((row, rowIndex) => (\n//              <div key={rowIndex} className=\"grid-row\">\n//                {row.map((col, colIndex) => (\n//                  <div\n//                    key={colIndex}\n//                    className=\"grid-cell\"\n//                    onClick={() => handleCellClick(rowIndex, colIndex)}\n//                  >\n//                    {col}\n//                  </div>\n//                ))}\n//              </div>\n//            ))}\n//          </div>\n//        </div>\n//      );\n//  }}\n\nexport default function App(props) {\n const [currentPlayer, setCurrentPlayer] = useState('X');\n\n  // State to keep track of the cells and their contents\n  const [grid, setGrid] = useState([\n    ['', '', ''],\n    ['', '', ''],\n    ['', '', ''],\n  ]);\n\n  // Function to handle clicks on the grid cells\n  const handleCellClick = async (row, col) => {\n    // Ignore the click if the cell is already filled\n    if (grid[row][col] !== '') {\n      return;\n    }\n\n    // Update the grid with the current player's symbol\n    const updatedGrid = [...grid];\n    updatedGrid[row][col] = currentPlayer;\n    const mv = fetch('http://localhost:8080/board', {\n                  method: 'PUT',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({ pos: row*3 + col}),\n                })\n      .then(response => response.json());\n\n                fetch('http://localhost:8080/board')\n      .then(response => console.log(response.json()));\n    // Switch to the other player\n    const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n\n    if (nextPlayer === 'O') {\n            fetch('http://localhost:8080/ai')\n              .then(response => response.json())\n              .then(aiMove => {\n                // Update the grid with the AI's move\n                var newGrid = [...updatedGrid];\n                newGrid[Math.floor(aiMove/3)][aiMove%3] = 'O';\n                var newBoard = [].concat.apply([], newGrid);\n                console.log(\"HEY\");\n                console.log(newBoard);\n                // Check if the game is over after the AI's move\n                const newGameOver = false;\n\n                // Update the state with the new grid and current player\n                setGrid(newGrid);\n                setCurrentPlayer(newGameOver ? 'O' : 'X');\n                \n                // Send the updated game state to the API\n                console.log(JSON.stringify({ pos: aiMove}));\n\n                \n              });\n          }\n\n    // Update the state with the new grid and current player\n    setGrid(updatedGrid);\n    setCurrentPlayer(currentPlayer);\n  }\n\n  return (\n    <div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((col, colIndex) => (\n              <div\n                key={colIndex}\n                className=\"grid-cell\"\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {col}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Log to console\nconsole.log('Hello console')\n\n\n// Log to console\nconsole.log('Hello console')\n\n\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA,eAAe,SAASC,GAAG,CAACC,KAAK,EAAE;EAAA;EAClC,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGL,QAAQ,CAAC,GAAG,CAAC;;EAEtD;EACA,MAAM,CAACM,IAAI,EAAEC,OAAO,CAAC,GAAGP,QAAQ,CAAC,CAC/B,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACZ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACZ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CACb,CAAC;;EAEF;EACA,MAAMQ,eAAe,GAAG,OAAOC,GAAG,EAAEC,GAAG,KAAK;IAC1C;IACA,IAAIJ,IAAI,CAACG,GAAG,CAAC,CAACC,GAAG,CAAC,KAAK,EAAE,EAAE;MACzB;IACF;;IAEA;IACA,MAAMC,WAAW,GAAG,CAAC,GAAGL,IAAI,CAAC;IAC7BK,WAAW,CAACF,GAAG,CAAC,CAACC,GAAG,CAAC,GAAGN,aAAa;IACrC,MAAMQ,EAAE,GAAGC,KAAK,CAAC,6BAA6B,EAAE;MAClCC,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE;QAAE,cAAc,EAAE;MAAmB,CAAC;MAC/CC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QAAEC,GAAG,EAAEV,GAAG,GAAC,CAAC,GAAGC;MAAG,CAAC;IAC1C,CAAC,CAAC,CACXU,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,EAAE,CAAC;IAExBT,KAAK,CAAC,6BAA6B,CAAC,CAC7CO,IAAI,CAACC,QAAQ,IAAIE,OAAO,CAACC,GAAG,CAACH,QAAQ,CAACC,IAAI,EAAE,CAAC,CAAC;IACjD;IACA,MAAMG,UAAU,GAAGrB,aAAa,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;IAEpD,IAAIqB,UAAU,KAAK,GAAG,EAAE;MAChBZ,KAAK,CAAC,0BAA0B,CAAC,CAC9BO,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,EAAE,CAAC,CACjCF,IAAI,CAACM,MAAM,IAAI;QACd;QACA,IAAIC,OAAO,GAAG,CAAC,GAAGhB,WAAW,CAAC;QAC9BgB,OAAO,CAACC,IAAI,CAACC,KAAK,CAACH,MAAM,GAAC,CAAC,CAAC,CAAC,CAACA,MAAM,GAAC,CAAC,CAAC,GAAG,GAAG;QAC7C,IAAII,QAAQ,GAAG,EAAE,CAACC,MAAM,CAACC,KAAK,CAAC,EAAE,EAAEL,OAAO,CAAC;QAC3CJ,OAAO,CAACC,GAAG,CAAC,KAAK,CAAC;QAClBD,OAAO,CAACC,GAAG,CAACM,QAAQ,CAAC;QACrB;QACA,MAAMG,WAAW,GAAG,KAAK;;QAEzB;QACA1B,OAAO,CAACoB,OAAO,CAAC;QAChBtB,gBAAgB,CAAC4B,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;QAEzC;QACAV,OAAO,CAACC,GAAG,CAACP,IAAI,CAACC,SAAS,CAAC;UAAEC,GAAG,EAAEO;QAAM,CAAC,CAAC,CAAC;MAG7C,CAAC,CAAC;IACN;;IAEN;IACAnB,OAAO,CAACI,WAAW,CAAC;IACpBN,gBAAgB,CAACD,aAAa,CAAC;EACjC,CAAC;EAED,oBACE;IAAA,uBACE;MAAK,SAAS,EAAC,MAAM;MAAA,UAClBE,IAAI,CAAC4B,GAAG,CAAC,CAACzB,GAAG,EAAE0B,QAAQ,kBACtB;QAAoB,SAAS,EAAC,UAAU;QAAA,UACrC1B,GAAG,CAACyB,GAAG,CAAC,CAACxB,GAAG,EAAE0B,QAAQ,kBACrB;UAEE,SAAS,EAAC,WAAW;UACrB,OAAO,EAAE,MAAM5B,eAAe,CAAC2B,QAAQ,EAAEC,QAAQ,CAAE;UAAA,UAElD1B;QAAG,GAJC0B,QAAQ;UAAA;UAAA;UAAA;QAAA,QAMhB;MAAC,GATMD,QAAQ;QAAA;QAAA;QAAA;MAAA,QAWnB;IAAC;MAAA;MAAA;MAAA;IAAA;EACE;IAAA;IAAA;IAAA;EAAA,QACF;AAEV;;AAEA;AAAA,GAlFwBjC,GAAG;AAAA,KAAHA,GAAG;AAmF3BqB,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;;AAG5B;AACAD,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}