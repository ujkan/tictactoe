{"ast":null,"code":"var _jsxFileName = \"/Users/ujkan/Desktop/uni/projects/tictactoe/java/src/main/resources/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\n\n//const App = () => {\n//  // State to keep track of the current player (X or O)\n//  const [currentPlayer, setCurrentPlayer] = useState('X');\n//\n//  // State to keep track of the cells and their contents\n//  const [grid, setGrid] = useState([\n//    ['', '', ''],\n//    ['', '', ''],\n//    ['', '', ''],\n//  ]);\n//\n//  // Fetch the current game state from the API when the component mounts\n//  useEffect(() => {\n//    fetch('/board')\n//      .then(response => response.json())\n//      .then(data => {\n//        setGrid(data.grid);\n//        setCurrentPlayer(data.currentPlayer);\n//      });\n//  }, []);\n//\n//  // Function to handle clicks on the grid cells\n//  const handleCellClick = (row, col) => {\n//    // Ignore the click if the cell is already filled\n//    if (grid[row][col] !== '') {\n//      return;\n//    }\n//\n//    // Update the grid with the current player's symbol\n//    const updatedGrid = [...grid];\n//    updatedGrid[row][col] = currentPlayer;\n//\n//    // Check if the game is over\n//    const gameOver = false;\n//\n//    let nextPlayer;\n//    if (gameOver) {\n//      // If the game is over, don't switch to the other player\n//      nextPlayer = currentPlayer;\n//    } else {\n//      // Switch to the other player\n//      nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n//\n//      // If the other player is the AI, make a move on behalf of the AI\n//      if (nextPlayer === 'O') {\n//        fetch('/ai')\n//          .then(response => response.json())\n//          .then(aiMove => {\n//            // Update the grid with the AI's move\n//            const newGrid = [...updatedGrid];\n//            newGrid[aiMove.row][aiMove.col] = 'O';\n//\n//            // Check if the game is over after the AI's move\n//            const newGameOver = false;\n//\n//            // Update the state with the new grid and current player\n//            setGrid(newGrid);\n//            setCurrentPlayer(newGameOver ? 'O' : 'X');\n//\n//            // Send the updated game state to the API\n//            fetch('../../src/api/game', {\n//              method: 'PUT',\n//              headers: { 'Content-Type': 'application/json' },\n//              body: JSON.stringify({ grid: newGrid, currentPlayer: nextPlayer }),\n//            });\n//          });\n//      }\n//    }\n//\n//    // Update the state with the new grid and current player\n//    setGrid(updatedGrid);\n//    setCurrentPlayer(nextPlayer);\n//\n//    // Send the updated game state to the API\n//    fetch('/api/game', {\n//      method: 'PUT',\n//      headers: { 'Content-Type': 'application/json' },\n//      body: JSON.stringify({ grid: updatedGrid, currentPlayer\n//\n//      })\n//    });\n//    return (\n//        <div>\n//          <div className=\"grid\">\n//            {grid.map((row, rowIndex) => (\n//              <div key={rowIndex} className=\"grid-row\">\n//                {row.map((col, colIndex) => (\n//                  <div\n//                    key={colIndex}\n//                    className=\"grid-cell\"\n//                    onClick={() => handleCellClick(rowIndex, colIndex)}\n//                  >\n//                    {col}\n//                  </div>\n//                ))}\n//              </div>\n//            ))}\n//          </div>\n//        </div>\n//      );\n//  }}\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default function App(props) {\n  _s();\n  const [currentPlayer, setCurrentPlayer] = useState('X');\n\n  // State to keep track of the cells and their contents\n  const [grid, setGrid] = useState([['', '', ''], ['', '', ''], ['', '', '']]);\n\n  // Function to handle clicks on the grid cells\n  const handleCellClick = async (row, col) => {\n    // Ignore the click if the cell is already filled\n    if (grid[row][col] !== '') {\n      return;\n    }\n\n    // Update the grid with the current player's symbol\n    const updatedGrid = [...grid];\n    updatedGrid[row][col] = currentPlayer;\n    fetch('http://localhost:8080/state').then(response => response.json()).then(json => console.log(json));\n    fetch('http://localhost:8080/board', {\n      method: 'PUT',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        pos: row * 3 + col\n      })\n    }).then(() => fetch('http://localhost:8080/ai').then(response => response.json()).then(aiMove => {\n      // Update the grid with the AI's move\n      var newGrid = [...updatedGrid];\n      newGrid[Math.floor(aiMove / 3)][aiMove % 3] = 'O';\n      var newBoard = [].concat.apply([], newGrid);\n      console.log(\"HEY\");\n      console.log(newBoard);\n      // Check if the game is over after the AI's move\n      const newGameOver = false;\n\n      // Update the state with the new grid and current player\n      setGrid(newGrid);\n      setCurrentPlayer(newGameOver ? 'O' : 'X');\n\n      // Send the updated game state to the API\n      console.log(JSON.stringify({\n        pos: aiMove\n      }));\n    }));\n\n    // Switch to the other player\n    const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n\n    // if (nextPlayer === 'O') {\n    //         fetch('http://localhost:8080/ai')\n    //           .then(response => response.json())\n    //           .then(aiMove => {\n    //             // Update the grid with the AI's move\n    //             var newGrid = [...updatedGrid];\n    //             newGrid[Math.floor(aiMove/3)][aiMove%3] = 'O';\n    //             var newBoard = [].concat.apply([], newGrid);\n    //             console.log(\"HEY\");\n    //             console.log(newBoard);\n    //             // Check if the game is over after the AI's move\n    //             const newGameOver = false;\n\n    //             // Update the state with the new grid and current player\n    //             setGrid(newGrid);\n    //             setCurrentPlayer(newGameOver ? 'O' : 'X');\n\n    //             // Send the updated game state to the API\n    //             console.log(JSON.stringify({ pos: aiMove}));\n\n    //           });\n    //       }\n\n    // Update the state with the new grid and current player\n    setGrid(updatedGrid);\n    setCurrentPlayer(currentPlayer);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    children: /*#__PURE__*/_jsxDEV(\"div\", {\n      className: \"grid\",\n      children: grid.map((row, rowIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"grid-row\",\n        children: row.map((col, colIndex) => /*#__PURE__*/_jsxDEV(\"div\", {\n          className: \"grid-cell\",\n          onClick: () => handleCellClick(rowIndex, colIndex),\n          children: col\n        }, colIndex, false, {\n          fileName: _jsxFileName,\n          lineNumber: 197,\n          columnNumber: 15\n        }, this))\n      }, rowIndex, false, {\n        fileName: _jsxFileName,\n        lineNumber: 195,\n        columnNumber: 11\n      }, this))\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 193,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 192,\n    columnNumber: 5\n  }, this);\n}\n\n// Log to console\n_s(App, \"rTbbhWrsBR3E1G1G/aa4g6E6TPM=\");\n_c = App;\nconsole.log('Hello console');\n\n// Log to console\nconsole.log('Hello console');\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","App","props","currentPlayer","setCurrentPlayer","grid","setGrid","handleCellClick","row","col","updatedGrid","fetch","then","response","json","console","log","method","headers","body","JSON","stringify","pos","aiMove","newGrid","Math","floor","newBoard","concat","apply","newGameOver","nextPlayer","map","rowIndex","colIndex"],"sources":["/Users/ujkan/Desktop/uni/projects/tictactoe/java/src/main/resources/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\n\n//const App = () => {\n//  // State to keep track of the current player (X or O)\n//  const [currentPlayer, setCurrentPlayer] = useState('X');\n//\n//  // State to keep track of the cells and their contents\n//  const [grid, setGrid] = useState([\n//    ['', '', ''],\n//    ['', '', ''],\n//    ['', '', ''],\n//  ]);\n//\n//  // Fetch the current game state from the API when the component mounts\n//  useEffect(() => {\n//    fetch('/board')\n//      .then(response => response.json())\n//      .then(data => {\n//        setGrid(data.grid);\n//        setCurrentPlayer(data.currentPlayer);\n//      });\n//  }, []);\n//\n//  // Function to handle clicks on the grid cells\n//  const handleCellClick = (row, col) => {\n//    // Ignore the click if the cell is already filled\n//    if (grid[row][col] !== '') {\n//      return;\n//    }\n//\n//    // Update the grid with the current player's symbol\n//    const updatedGrid = [...grid];\n//    updatedGrid[row][col] = currentPlayer;\n//\n//    // Check if the game is over\n//    const gameOver = false;\n//\n//    let nextPlayer;\n//    if (gameOver) {\n//      // If the game is over, don't switch to the other player\n//      nextPlayer = currentPlayer;\n//    } else {\n//      // Switch to the other player\n//      nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n//\n//      // If the other player is the AI, make a move on behalf of the AI\n//      if (nextPlayer === 'O') {\n//        fetch('/ai')\n//          .then(response => response.json())\n//          .then(aiMove => {\n//            // Update the grid with the AI's move\n//            const newGrid = [...updatedGrid];\n//            newGrid[aiMove.row][aiMove.col] = 'O';\n//\n//            // Check if the game is over after the AI's move\n//            const newGameOver = false;\n//\n//            // Update the state with the new grid and current player\n//            setGrid(newGrid);\n//            setCurrentPlayer(newGameOver ? 'O' : 'X');\n//\n//            // Send the updated game state to the API\n//            fetch('../../src/api/game', {\n//              method: 'PUT',\n//              headers: { 'Content-Type': 'application/json' },\n//              body: JSON.stringify({ grid: newGrid, currentPlayer: nextPlayer }),\n//            });\n//          });\n//      }\n//    }\n//\n//    // Update the state with the new grid and current player\n//    setGrid(updatedGrid);\n//    setCurrentPlayer(nextPlayer);\n//\n//    // Send the updated game state to the API\n//    fetch('/api/game', {\n//      method: 'PUT',\n//      headers: { 'Content-Type': 'application/json' },\n//      body: JSON.stringify({ grid: updatedGrid, currentPlayer\n//\n//      })\n//    });\n//    return (\n//        <div>\n//          <div className=\"grid\">\n//            {grid.map((row, rowIndex) => (\n//              <div key={rowIndex} className=\"grid-row\">\n//                {row.map((col, colIndex) => (\n//                  <div\n//                    key={colIndex}\n//                    className=\"grid-cell\"\n//                    onClick={() => handleCellClick(rowIndex, colIndex)}\n//                  >\n//                    {col}\n//                  </div>\n//                ))}\n//              </div>\n//            ))}\n//          </div>\n//        </div>\n//      );\n//  }}\n\nexport default function App(props) {\n const [currentPlayer, setCurrentPlayer] = useState('X');\n\n  // State to keep track of the cells and their contents\n  const [grid, setGrid] = useState([\n    ['', '', ''],\n    ['', '', ''],\n    ['', '', ''],\n  ]);\n\n  // Function to handle clicks on the grid cells\n  const handleCellClick = async (row, col) => {\n    // Ignore the click if the cell is already filled\n    if (grid[row][col] !== '') {\n      return;\n    }\n\n    // Update the grid with the current player's symbol\n    const updatedGrid = [...grid];\n    updatedGrid[row][col] = currentPlayer;\n    \n    fetch('http://localhost:8080/state')\n    .then(response => response.json())\n    .then(json => console.log(json))\n\n    fetch('http://localhost:8080/board', {\n                  method: 'PUT',\n                  headers: { 'Content-Type': 'application/json' },\n                  body: JSON.stringify({ pos: row*3 + col}),\n                })\n      .then(() =>\n        fetch('http://localhost:8080/ai')\n              .then(response => response.json())\n              .then(aiMove => {\n                // Update the grid with the AI's move\n                var newGrid = [...updatedGrid];\n                newGrid[Math.floor(aiMove/3)][aiMove%3] = 'O';\n                var newBoard = [].concat.apply([], newGrid);\n                console.log(\"HEY\");\n                console.log(newBoard);\n                // Check if the game is over after the AI's move\n                const newGameOver = false;\n\n                // Update the state with the new grid and current player\n                setGrid(newGrid);\n                setCurrentPlayer(newGameOver ? 'O' : 'X');\n                \n                // Send the updated game state to the API\n                console.log(JSON.stringify({ pos: aiMove}));\n\n                \n              }))\n\n\n    // Switch to the other player\n    const nextPlayer = currentPlayer === 'X' ? 'O' : 'X';\n\n    // if (nextPlayer === 'O') {\n    //         fetch('http://localhost:8080/ai')\n    //           .then(response => response.json())\n    //           .then(aiMove => {\n    //             // Update the grid with the AI's move\n    //             var newGrid = [...updatedGrid];\n    //             newGrid[Math.floor(aiMove/3)][aiMove%3] = 'O';\n    //             var newBoard = [].concat.apply([], newGrid);\n    //             console.log(\"HEY\");\n    //             console.log(newBoard);\n    //             // Check if the game is over after the AI's move\n    //             const newGameOver = false;\n\n    //             // Update the state with the new grid and current player\n    //             setGrid(newGrid);\n    //             setCurrentPlayer(newGameOver ? 'O' : 'X');\n                \n    //             // Send the updated game state to the API\n    //             console.log(JSON.stringify({ pos: aiMove}));\n\n                \n    //           });\n    //       }\n\n    // Update the state with the new grid and current player\n    setGrid(updatedGrid);\n    setCurrentPlayer(currentPlayer);\n  }\n\n  return (\n    <div>\n      <div className=\"grid\">\n        {grid.map((row, rowIndex) => (\n          <div key={rowIndex} className=\"grid-row\">\n            {row.map((col, colIndex) => (\n              <div\n                key={colIndex}\n                className=\"grid-cell\"\n                onClick={() => handleCellClick(rowIndex, colIndex)}\n              >\n                {col}\n              </div>\n            ))}\n          </div>\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Log to console\nconsole.log('Hello console')\n\n\n// Log to console\nconsole.log('Hello console')\n\n\n"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA,eAAe,SAASC,GAAG,CAACC,KAAK,EAAE;EAAA;EAClC,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGL,QAAQ,CAAC,GAAG,CAAC;;EAEtD;EACA,MAAM,CAACM,IAAI,EAAEC,OAAO,CAAC,GAAGP,QAAQ,CAAC,CAC/B,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACZ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,EACZ,CAAC,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CACb,CAAC;;EAEF;EACA,MAAMQ,eAAe,GAAG,OAAOC,GAAG,EAAEC,GAAG,KAAK;IAC1C;IACA,IAAIJ,IAAI,CAACG,GAAG,CAAC,CAACC,GAAG,CAAC,KAAK,EAAE,EAAE;MACzB;IACF;;IAEA;IACA,MAAMC,WAAW,GAAG,CAAC,GAAGL,IAAI,CAAC;IAC7BK,WAAW,CAACF,GAAG,CAAC,CAACC,GAAG,CAAC,GAAGN,aAAa;IAErCQ,KAAK,CAAC,6BAA6B,CAAC,CACnCC,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,EAAE,CAAC,CACjCF,IAAI,CAACE,IAAI,IAAIC,OAAO,CAACC,GAAG,CAACF,IAAI,CAAC,CAAC;IAEhCH,KAAK,CAAC,6BAA6B,EAAE;MACvBM,MAAM,EAAE,KAAK;MACbC,OAAO,EAAE;QAAE,cAAc,EAAE;MAAmB,CAAC;MAC/CC,IAAI,EAAEC,IAAI,CAACC,SAAS,CAAC;QAAEC,GAAG,EAAEd,GAAG,GAAC,CAAC,GAAGC;MAAG,CAAC;IAC1C,CAAC,CAAC,CACXG,IAAI,CAAC,MACJD,KAAK,CAAC,0BAA0B,CAAC,CAC1BC,IAAI,CAACC,QAAQ,IAAIA,QAAQ,CAACC,IAAI,EAAE,CAAC,CACjCF,IAAI,CAACW,MAAM,IAAI;MACd;MACA,IAAIC,OAAO,GAAG,CAAC,GAAGd,WAAW,CAAC;MAC9Bc,OAAO,CAACC,IAAI,CAACC,KAAK,CAACH,MAAM,GAAC,CAAC,CAAC,CAAC,CAACA,MAAM,GAAC,CAAC,CAAC,GAAG,GAAG;MAC7C,IAAII,QAAQ,GAAG,EAAE,CAACC,MAAM,CAACC,KAAK,CAAC,EAAE,EAAEL,OAAO,CAAC;MAC3CT,OAAO,CAACC,GAAG,CAAC,KAAK,CAAC;MAClBD,OAAO,CAACC,GAAG,CAACW,QAAQ,CAAC;MACrB;MACA,MAAMG,WAAW,GAAG,KAAK;;MAEzB;MACAxB,OAAO,CAACkB,OAAO,CAAC;MAChBpB,gBAAgB,CAAC0B,WAAW,GAAG,GAAG,GAAG,GAAG,CAAC;;MAEzC;MACAf,OAAO,CAACC,GAAG,CAACI,IAAI,CAACC,SAAS,CAAC;QAAEC,GAAG,EAAEC;MAAM,CAAC,CAAC,CAAC;IAG7C,CAAC,CAAC,CAAC;;IAGb;IACA,MAAMQ,UAAU,GAAG5B,aAAa,KAAK,GAAG,GAAG,GAAG,GAAG,GAAG;;IAEpD;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;IAEA;IACA;IACA;;IAEA;IACA;;IAGA;IACA;;IAEA;IACAG,OAAO,CAACI,WAAW,CAAC;IACpBN,gBAAgB,CAACD,aAAa,CAAC;EACjC,CAAC;EAED,oBACE;IAAA,uBACE;MAAK,SAAS,EAAC,MAAM;MAAA,UAClBE,IAAI,CAAC2B,GAAG,CAAC,CAACxB,GAAG,EAAEyB,QAAQ,kBACtB;QAAoB,SAAS,EAAC,UAAU;QAAA,UACrCzB,GAAG,CAACwB,GAAG,CAAC,CAACvB,GAAG,EAAEyB,QAAQ,kBACrB;UAEE,SAAS,EAAC,WAAW;UACrB,OAAO,EAAE,MAAM3B,eAAe,CAAC0B,QAAQ,EAAEC,QAAQ,CAAE;UAAA,UAElDzB;QAAG,GAJCyB,QAAQ;UAAA;UAAA;UAAA;QAAA,QAMhB;MAAC,GATMD,QAAQ;QAAA;QAAA;QAAA;MAAA,QAWnB;IAAC;MAAA;MAAA;MAAA;IAAA;EACE;IAAA;IAAA;IAAA;EAAA,QACF;AAEV;;AAEA;AAAA,GA3GwBhC,GAAG;AAAA,KAAHA,GAAG;AA4G3Bc,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;;AAG5B;AACAD,OAAO,CAACC,GAAG,CAAC,eAAe,CAAC;AAAA;AAAA"},"metadata":{},"sourceType":"module","externalDependencies":[]}